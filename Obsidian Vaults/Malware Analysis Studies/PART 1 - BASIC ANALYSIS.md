
## Chapter 1: Basic Static Techniques

### Antivirus Scanning: A Useful First Step
- when analyzing prospective malware, a good first step is to run it through multiple antivirus software, which might have already identified it. 
- antivirus isn't perfect, it relies on:
	- **File Signatures** - identifiable pieces of known suspicious code
	- **Heuristics** - pattern-matching analysis
- reasons why antivirus scanning might not be as useful:
	- malware writers can easily modify their code to bypass antivirus since that specific version of code isn't in the signatures
	- heuristics might be good for identifying unknown malicious code, it can be bypassed by new and unique malware
- because AV use different signatures and heuristics, *it's good to use multiple of them against the same piece of malware.*
- good website to use:
	- [VirusTotal](https://www.virustotal.com/gui/home/upload) -  allows you to upload a file to scan through multiple antivirus engines. generates a report that provides:
		- the total number of engines that marked the file as malicious
		- malware name
		- (if available) additional information about the malware

### Hashing: A Fingerprint for Malware
- hashing is a method used to identify malware
- malware is run through a hashing program that produces a unique hash that identifies it
- **Message Digest Algorithm 5 (MD5)** is the most common for malware analysis
- **Secure Hash Algorithm 1 (SHA-1)** is also popular
- when you have a unique has for malware you can use it for:
	- a label
	- sharing the hash with other analysts to help them identify the malware
	- searching for the hash online to see if the file has been identified

### Finding Strings
- **strings** are defined as a sequence of characters
- a program contains strings if it: prints a message, connects to a URL, or copies a file to a specific location
- searching through strings can be a good way to see the functionality of a program
	- example: using the strings program to search an executable for the strings stored in either ASCII or Unicode 
	- learn more about this program in "[[SysInternals - Strings]]"

NOTE: microsoft uses the term "wide character string" to describe unicode strings, which vary slightly from unicode standards. Whenever the book refers to unicode, they refer to microsoft's implementation. 

- ASCII and Unicode store characters in sequences that end with a NULL terminator (indicating when the string is complete)
- ASCII uses 1 Byte per character
- Unicode uses 2 Bytes per character

![[Pasted image 20251027005624.png]]

![[Pasted image 20251027005644.png]]

- when MS Strings searches an executable for ASCII and Unicode, it ignores context and formatting so it can analyze any filetype and detect strings across the entire file (this means it may also identify bytes of characters as strings even when they're not)
- MS Strings searches for 3=< sequence of characters, followed by a terminator
- MS Strings leaves it up to the user to filter out invalid strings, thankfully most of those invalid strings are obvious, since they don't represent legitimate text. 
- often the most useful information obtained from using MS Strings is found in the error messages printed

## Packed and Obfuscated Malware
- **obfuscated programs** have their execution instructions hidden by the author
- **packed programs** are compressed and cannot be analyzed
- both techniques severely limit static analysis
- legitimate programs have several strings, while obfuscated ones do not. *if you encounter a program with very few strings, there's a likelihood the program is either packed or obfuscated.* 

NOTE: Packed and obfuscated code will often include at least the functions `LoadLibrary` and `GetProcAddress` which are used to load and gain access to additional functions

### Packing Files
- when a packed program is run, a small wrapper program runs with it to decompress the file, then run the unpacked file.
- *when a packed program is analyzed statically, only the wrapper can be dissected.* 

### Detecting Packers with PEiD
- a program you can use to detect packed files
- can detect the type of packer or compiler used to build an application, which makes analyzing the file much easier. 

NOTE: development and support for PEiD has been discontinued since April of 2011, but it's still considered the best tool for packer and compiler detection. 

- when a program is packed, you need to unpack it to perform any sort of analysis. 
- unpacking process is complex and covered in detail in [[PART 5 - ANTI-REVERSE ENGINEERING]]
- UPX packing program is popular and easy to use, so it gets mentioned here:
	- to unpack any malware packed with UPX, you should download UPX and unpack by using the packed program as an input
		- `upx -d PackedProgram.exe`

NOTE: Many PEiD programs will execute programs without warning. Also, like all programs, especially those for malware analysis, can be subjected to vulnerabilities. PEiD v0.92 contained a buffer overflow that allowed an ACE (arbitrary code execution). Make sure you're always using the most up to date version of your programs

### Portable Executable File Format
- **Portable Executable (PE)**: format used by windows exes, object codes, and DLLs
	- data structure containing information necessary for the winOS to manage the wrapped executable code (in other words it's the wrapper or container format used by windows programs)
- *every file containing executable code loaded by windows is in this format*, though some legacy file formats appear on rare occasion in malware. 
- PE files begin with a header that includes information about:
	- code
	- type of application
	- required library functions
	- space requirements
- information stored in the PE header is of great value to a malware analyst
- to learn more about this, check out "[[Understanding PE Headers]]"

## Linked Libraries and Functions
- one of the most important pieces of information gathered from an executable is the list of functions it imports
- **imports**: functions used by a program that are stored in another program, such as code libraries that contain functionality used in several other programs
- **linking** is the act of connecting code libraries to the main executable
- programmers link imports to their program so they don't have to reimplement functionalities every time. 
- code libraries can be **linked statically or dynamically**
- knowing how library codes are linked are important, s*ince the information found in the PE file header depends on how the library code is linked*

### Static, Runtime, and Dynamic Linking
- **Static Linking**: least commonly used method of library linking.
	- common in UNIX/Linux programs
	- when a library is statically linked, ***all code from the library is copied into the executable (causes the exe to grow in size)***
	- difficult to differentiate statically linked code and the exe's own code. ***Nothing in the PE header indicates that the file contains linked code.***
- **Runtime Linking**: unpopular in friendly programs, but common in malware
	- ***connect to libraries only when the function is needed, not program start (like dynamically linked programs)***
- several windows functions allow programmers to import linked functions that aren't listed in a program's file header. the two most common functions are `LoadLibrary` and `GetProcAddress`
	- `LdrGetProcAddress` and `LdrLoadDLL` are also used
	- `LoadLibrary` and `GetProcAddress` allows a program to access a function in any library on the system. When they're used, you can't tell statically which functions are being linked to by the program they're used in
- **Dynamic Linking**: most common and most interesting for malware analysts. 
	- when libraries are dynamically linked, the OS searches for the libraries when the program is loaded. When the program calls for the linked library function, the function is executed within the library.
	- PE file header stores the information about every library that will be loaded and every function that will be used by the program. 
	- ***libraries used and functions called are the most important parts of a program (and identifying them is just as important) because it helps us find out what the program does.*** 

### Exploring Dynamically Linked Functions with Dependency Walker
- the Dependency walker program is often distributed with some version of microsoft VS and other SDKs
- lists only Dynamically linked functions in an executable

Table of common DLLs and what they do

| DLL                        | Description                                                                                                                                                                                                                                                                                                                                                  |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Kernel32.dll               | common DLL containing core functionality, such as access manipulation and manipulation of memory, files, and hardware                                                                                                                                                                                                                                        |
| Advapi32.dll               | provides access to advanced core windows components such as the service manager and the registry                                                                                                                                                                                                                                                             |
| User32.dll                 | contains all user-interface components such as buttons, scroll bars, and components that control and respond to user actions                                                                                                                                                                                                                                 |
| Gdi32.dll                  | contains functions for displaying and manipulating graphics                                                                                                                                                                                                                                                                                                  |
| Ntdll.dll                  | interface to the windows kernel. executables don't import this file directly, although it's always indirectly imported by kernel32.dll. if an exe imports this file, it means the author intended to use functionality that isn't available to windows programs. Some tasks (such as hiding functionality or manipulating processes) will use this interface |
| Wsock32.dll and Ws2_32.dll | networking DLLs. a program that accesses either of these will most likely connect to a network or perform network-related tasks                                                                                                                                                                                                                              |
| Wininet.dll                | containers higher-level networking functions that implement protocols such as FTP, HTTP, and NTP                                                                                                                                                                                                                                                             |

### Function Naming Conventions:
- you will encounter function names with -Ex suffix (`CreateWindowEx)
- when microsoft updates a function and the new function is incompatible with the old version, ***the new function is given the same name as the older one, but with the suffix appended***
- functions updated twice have two ex suffices in their names.
- ***functions that take strings as parameters will include an A or a W at the end of their names*** (eg. `CreateDirectoryW`) but they don't appear in documentation for the function. 
	- the letter indicates that the function accepts a string parameter and that there are two different versions of the function:
		- A = ASCII
		- W = Wide Character strings

### Imported Functions
- PE file header includes information about specific functions used by the executable
- the name of the functions can give an idea of what an executable does
- microsoft documents the windows API via Microsoft Developer Network (MSDN) library

### Exported Functions
- DLLs and EXEs export functions to interact with other programs and code. 
- ***DLL implements one or more functions and exports them for use by an executable*** 
- PE File contains information about which functions are exported by a file
- EXEs are not designed to offer functionality to other EXEs, so any functions exported by them are rare. If you find any, they will provide useful information.
- software authors name their exported functions in a way that provides information.
	- common convention is the name used in the Microsoft documentation
		- example: to run a program as a service, you need to define a `ServiceMain` function. the presence of a function named this way tells you that the malware might run as a part of a service
		- some developers might follow this convention while others don't. 
- if you're analyzing malware using exports, it will omit names entirely or use misleading names

## Static Analysis in Practice:

### PotentialKeylogger.exe: an Unpacked Executable
- the example starts with a list of functions imported that were collected using dependency walker
- the presence of so many imports can help you lead to the conclusion that a file is not packed. 
- there will be various functions in a program, and you'll have to learn to identify which ones you need to identify when analyzing malware.
- when you're not sure what a function does, you need to look it up. you can check [[Appendix A - Important Windows Functions]] for reference!
- the example shows a list of unimportant functions, but delves into the ones that can be suspicious when looking at a keylogger.

## [[PE File Headers and Sections]]
- PE file headers can provide more information than just imports. 
- PE file format contains a header followed by a series of sections.
- **header** contains file metadata
- following the header are actual file sections, which contain useful information.
- section names appear consistent across one compiler, but can vary across different ones. Windows doesn't care about the actual name since it uses the information in the PE header to determine how the section is used
- section names are often obfuscated to make analysis difficult. 

Sections of a PE file for a windows executable:


| Executable | Description                                                                                                                                       |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| .text      | contains executable code                                                                                                                          |
| .rdata     | holds read-only data globally accessible within the program                                                                                       |
| .data      | stores global data accessed throughout the program                                                                                                |
| .idata     | sometimes presents and stores the import function information; if section is not present, the import function information may be stored in .rdata |
| .edata     | sometimes presents and stores the export function information; if section is not present, the export function information may be stored in .rdata |
| .pdata     | only appears in x64 executables and can store exception-handling information                                                                      |
| .rsrc      | stores the resources required by the executable                                                                                                   |
| .reloc     | contains the information for the relocation of library files                                                                                      |
