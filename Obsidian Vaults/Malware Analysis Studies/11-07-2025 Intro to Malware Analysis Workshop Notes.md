
- recorded future??
- pyramid of malware analysis (difficulty increases as you go from the bottom up):
	- manual code reversing
	- interactive behavior analysis
	- static properties analysis
	- fully automated analysis
- looking at the top 3 layers in today's workshop
- static properties = analyzing at rest
- interactive behavior = code on the move
- manual code reversion = analyzing at rest
- "maldocs" - what is that? 
	- too broad to be discussed in this workshop
	- aw man :c
- staying safe using live malware:
	- use virtual machines
	- use virtual machine snapshots
	- the samples used in this environment still have live backdoors
	- gold standard: reduce the attack surface when analyzing
		- if analyzing a windows virus, test in a windows virtual environment, on a linux machine
		- use inverse nesting 
	- just because you have a virtual machine, doesn't mean that it can't talk to the internet. So ensure your network is secure
- if you want to be able to run malware samples at home on a network you're having difficulty hardening, run malware on VMs that don't speak to the internet and see how they run, what their structure is, and understand what they would be doing if they had that capability
- he pretty much said: **if you don't know how to harden your network, you don't currently have the capability to run live malware**, so stick to samples that don't communicate to the internet and use the inverse nesting to reduce attack surface
- research other ways to disconnect the VM from the network when using it
	- in this workshop we used "host-only adapter" but it's not the most secure way to do it
- hashing and fuzzing are some of the most common ways to describe malware
- the hashes in the zip file were md5, it's the shortest algorithm, so it makes it easier to share
- check out the remnux documentation site to understand what it is
	- ubuntu-based reverse engineering and malware analysis OS

General commands (static)
- file
	- gives you basic information on the file
- trid
- magika
- there are special versions of malware that use .NET assemblies (look more into it!)

.NET analysis
- manalyze 
- peframe
- flarestrings
	- returns strings that are in the malware

- keywords to look into:
	- assembly
	- .cctor
	- as you build an understanding, you start to better filter the noise

- less reduces the amount of output a program spits out
	- example: floss (hash) | less

- base64 strings usually end in two equal signs
- before executing, make sure it does NOT resolve to anything on the internet
- what is the "watch" command?

- look up more stuff to learn about "wine"
- using top in the environment will let you see the current processes running on the system
	- if you want to kill the process, use `ps aux | grep <malware name>` then use `kill <PID>` to get it to stop
- ransomware takes up a majority of system resources due to encrypting files in the background, so also looking into the amount of CPU utilization the program is using can be an indicator of malware

DiE
- the UI can be accessed using die 
- the CLI interface can be accessed using diec
- the creator apparently really likes to patch the tool! so if any malware sample ends up crashing the program, you can reach out to him about it

- TA's will use packers to take an executable and change it in a way that makes it hard to tell the intent of the program (and makes it hard to understand program's true meaning)
- the protect field in die is the packer used to obfuscate the program
- understanding the packer lets you know how to deobfuscate
- learn about UPX packers to learn one of the most common packers
- packers scramble the order

- on your own time maybe research what the difference is between wrappers and packers?

- 3 ways of running code:
	- scripting
	- managed languages (java, c#, etc)
	- compiled languages

- .NET malware is compiled to an intermediate representation
- ilspycmd lets you find the intermediate language
- packed samples won't return the intermediate language, unpacked ones do
- for ransomware, you need to understand the encryption process and possibly reveng an algorithm that reverses that

- to decrypt files, you need the base64 key and the initialization vector (IV)
- one of the most used tools in the malware analysis/digital forensics spaces...CYBERCHEF
	- allows you to order a series of steps into a "recipe"

- in the workshop example, we use the AES decrypt function (since the malware encrypts using AES)
	- using the base64 string we found in the file, we use that as the key
	- the IV is a byte array, and you copy and paste it in as a hex value
		- cyberchef is smart enough to do this though! sometimes you should brute force it

- information dissemination is really important when discovering solutions like decrypting the malware

- make sure that when you're looking at a file in ghidra, you pay attention to import results summary
- when using ghidra, you'll more than likely be in the listing and decompile panes
- the entry point is the first function the program calls
- when analyzing, explore into anything under the window menu that includes "function" in the name to understand how functions are called and the relationships between functions or anything that uses "symbol"
	- some things to look at when analyzing:
		- `isdebuggerpresent` = "if someone is analyzing the code with a debugger, do something else"

- workshop2 is safe to run at home but please still remain cautious
- interactive behavior analysis is a really important skill to have

- what a debugger does is allow windows to load the program into memory and to place points in memory to watch the program execute 
- when you first start debugging, you need to go to the debug menu, then go over to run user code
- he considers debuggers to be the most important tool in malware analysis

- one of the first challenges when debugging malware with the flag is to find a way to work around the debug check
	- you can replace the instruction
		- je = jump if equal, replace to jmp and it skips the logic!
		- if you want to publish the edits made to the file, you can patch the file (you can't patch running files though)

- learn more about mutex! 